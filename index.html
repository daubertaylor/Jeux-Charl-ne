<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flappy Heart - For√™t enchant√©e</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to top, #317d49 0%, #a0d8ef 90%);
    font-family: 'Baloo 2', cursive;
  }
  canvas {
    display: block;
    background: transparent;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    touch-action: none;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 40, 25, 0.85);
    color: #f0f7e8;
    padding: 1.5em 2em;
    border-radius: 20px;
    text-align: center;
    font-size: 1.3rem;
    max-width: 90vw;
    display: none;
    user-select: none;
    box-shadow: 0 0 15px #84c885;
    z-index: 10;
  }
  #message button {
    margin-top: 1em;
    background: #4caf50;
    border: none;
    border-radius: 12px;
    padding: 0.8em 2em;
    font-weight: bold;
    color: white;
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    transition: background 0.3s ease;
  }
  #message button:hover {
    background: #388e3c;
  }
  #score {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 2.2rem;
    color: #f44336;
    font-weight: 900;
    text-shadow: 0 0 6px #ff6b81;
    user-select: none;
    z-index: 10;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="score">0</div>

<div id="message">
  <p>Ce n‚Äôest pas grave mon amour üíî<br>Tu as tout donn√©, je suis fier de toi.</p>
  <button id="restartBtn">Recommencer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let W, H, scale;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * devicePixelRatio;
    canvas.height = H * devicePixelRatio;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
    scale = Math.min(W/375, H/667);
  }
  resize();
  window.addEventListener('resize', resize);

  // Jeu variables
  const gravity = 0.5;
  const jumpForce = -9;
  const obstacleWidth = 60 * scale;
  const gapHeight = 140 * scale;
  const obstacleSpacing = 250 * scale;
  const scrollSpeed = 2.5 * scale;

  // Le c≈ìur volant
  const heart = {
    x: W/4,
    y: H/2,
    vy: 0,
    size: 38 * scale,
    pulseTime: 0,
  };

  let obstacles = [];
  let frames = 0;
  let score = 0;
  let running = true;

  const messageDiv = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');
  const scoreDiv = document.getElementById('score');

  restartBtn.onclick = () => {
    score = 0;
    heart.y = H/2;
    heart.vy = 0;
    obstacles = [];
    frames = 0;
    running = true;
    messageDiv.style.display = 'none';
    scoreDiv.textContent = '0';
    addObstacle();
    loop();
  };

  // Dessine un c≈ìur stylis√© dessin anim√©, qui pulse
  function drawHeart(x, y, size, pulseScale = 1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(pulseScale, pulseScale);

    const topCurveHeight = size * 0.3;
    ctx.beginPath();
    ctx.moveTo(0, topCurveHeight);
    ctx.bezierCurveTo(0, 0, -size / 2, 0, -size / 2, topCurveHeight);
    ctx.bezierCurveTo(-size / 2, size / 2, 0, size * 0.75, 0, size);
    ctx.bezierCurveTo(0, size * 0.75, size / 2, size / 2, size / 2, topCurveHeight);
    ctx.bezierCurveTo(size / 2, 0, 0, 0, 0, topCurveHeight);
    ctx.closePath();

    const grad = ctx.createRadialGradient(0, size/2, size*0.1, 0, size/2, size);
    grad.addColorStop(0, '#ff4c62');
    grad.addColorStop(1, '#a80020');
    ctx.fillStyle = grad;

    ctx.shadowColor = 'rgba(255, 76, 98, 0.9)';
    ctx.shadowBlur = 14;

    ctx.fill();
    ctx.restore();
  }

  // Arbre stylis√© (tronc + feuillage arrondi)
  function drawTree(x, y, height, sway=0) {
    ctx.save();
    ctx.translate(x + sway, y);

    // Tronc
    ctx.fillStyle = '#4a2e0f';
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 4;
    ctx.fillRect(-8 * scale, 0, 16 * scale, height);

    // Feuillage (3 cercles)
    ctx.fillStyle = '#3a7d3c';
    ctx.shadowColor = 'rgba(20,60,15,0.5)';
    ctx.shadowBlur = 10;
    const r = 24 * scale;
    ctx.beginPath();
    ctx.ellipse(0, -r * 0.7, r, r * 0.75, 0, 0, Math.PI*2);
    ctx.ellipse(-r, -r * 1.3, r, r, 0, 0, Math.PI*2);
    ctx.ellipse(r, -r * 1.3, r, r, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Nuage doux stylis√©
  function drawCloud(x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.shadowColor = 'rgba(200,200,210,0.8)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
    ctx.ellipse(size * 0.5, -size * 0.1, size * 0.55, size * 0.45, 0, 0, Math.PI * 2);
    ctx.ellipse(size * 0.9, size * 0.1, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Branches fines en bas des obstacles pour effet for√™t
  function drawBranches(x, y, length, sway=0) {
    ctx.save();
    ctx.translate(x + sway, y);
    ctx.strokeStyle = '#265318';
    ctx.lineWidth = 3 * scale;
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(length * 0.6, -length * 0.5);
    ctx.moveTo(0, 0);
    ctx.lineTo(-length * 0.5, -length * 0.7);
    ctx.stroke();

    // petites feuilles
    ctx.fillStyle = '#3a7d3c';
    ctx.beginPath();
    ctx.ellipse(length * 0.6, -length * 0.5, 6 * scale, 10 * scale, 0.5, 0, Math.PI * 2);
    ctx.ellipse(-length * 0.5, -length * 0.7, 6 * scale, 10 * scale, -0.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Obstacle arbre (haut et bas avec trou)
  function Obstacle(x) {
    this.x = x;
    this.heightTop = 80 * scale + Math.random() * (H - gapHeight - 160 * scale);
    this.heightBottom = H - this.heightTop - gapHeight;
    this.swayPhase = Math.random() * Math.PI * 2;
  }

  Obstacle.prototype.update = function() {
    this.x -= scrollSpeed;
    this.swayPhase += 0.03;
  }

  Obstacle.prototype.draw = function() {
    // Sway = oscillation horizontale douce
    const swayX = Math.sin(this.swayPhase) * 6 * scale;

    // arbre bas
    drawTree(this.x + swayX, H - this.heightBottom, this.heightBottom);

    // arbre haut (retourn√©)
    ctx.save();
    ctx.translate(this.x + swayX, this.heightTop);
    ctx.scale(1, -1);
    drawTree(0, 0, this.heightTop);
    ctx.restore();

    // branches suppl√©mentaires
    drawBranches(this.x + swayX, H - this.heightBottom, 40 * scale, swayX/2);
    drawBranches(this.x + swayX, this.heightTop, 40 * scale, swayX/2);
  }

  function addObstacle() {
    const lastX = obstacles.length ? obstacles[obstacles.length -1].x : W + 100 * scale;
    obstacles.push(new Obstacle(lastX + obstacleSpacing));
  }

  function checkCollision(rectX, rectY, rectW, rectH, circleX, circleY, circleR) {
    // simple AABB to circle collision test
    const closestX = Math.max(rectX, Math.min(circleX, rectX + rectW));
    const closestY = Math.max(rectY, Math.min(circleY, rectY + rectH));

    const dx = circleX - closestX;
    const dy = circleY - closestY;

    return (dx * dx + dy * dy) < (circleR * circleR);
  }

  function showMessage() {
    running = false;
    message

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flappy Coeur</title>
<style>
  * {
    margin:0; padding:0; box-sizing: border-box;
  }
  html, body {
    height:100%;
    background: linear-gradient(to bottom, #4a90e2 0%, #b1d1fc 100%);
    overflow:hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    -webkit-tap-highlight-color: transparent;
  }
  canvas {
    display: block;
    margin: auto;
    background: transparent;
    touch-action: manipulation;
  }
  #score {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #d42b3f;
    font-size: 2.5em;
    font-weight: 700;
    text-shadow: 1px 1px 4px #000;
    user-select: none;
    z-index: 10;
  }
  #message {
    position: fixed;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    color: #d42b3f;
    padding: 25px 40px;
    border-radius: 15px;
    font-size: 1.4em;
    text-align: center;
    box-shadow: 0 0 15px rgba(212,43,63,0.8);
    user-select: none;
    display: none;
    max-width: 90vw;
    line-height: 1.4;
    z-index: 20;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="score">0</div>
<div id="message">Câ€™est pas grave mon amour,<br>chaque essai te rapproche un peu plus du ciel ðŸ’–</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let width, height;
  function resize() {
    width = Math.min(window.innerWidth, 400);
    height = Math.min(window.innerHeight, 700);
    canvas.width = width;
    canvas.height = height;
  }
  resize();
  window.addEventListener('resize', resize);

  // Game constants
  const gravity = 0.5;
  const jumpPower = -9;
  const obstacleWidth = 50;
  const gapHeight = 160;
  const obstacleSpacing = 220;

  // Heart character
  const heart = {
    x: width / 4,
    y: height / 2,
    vy: 0,
    radius: 22,
    pulseScale: 1,
    pulseDir: 1,
    pulseSpeed: 0.04,
  };

  // Obstacles array
  let obstacles = [];
  let frame = 0;
  let score = 0;
  let gameOver = false;

  const messageDiv = document.getElementById('message');
  const scoreDiv = document.getElementById('score');

  // Draw heart shape function
  function drawHeart(x, y, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size, size);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(0, -0.5, -0.5, -0.5, -0.5, 0);
    ctx.bezierCurveTo(-0.5, 0.5, 0, 0.9, 0, 1.3);
    ctx.bezierCurveTo(0, 0.9, 0.5, 0.5, 0.5, 0);
    ctx.bezierCurveTo(0.5, -0.5, 0, -0.5, 0, 0);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.shadowColor = '#b50000';
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.restore();
  }

  // Draw circle helper for tree foliage
  function drawCircle(x, y, r, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.shadowColor = '#1a4b1a';
    ctx.shadowBlur = 5;
    ctx.ellipse(x, y, r, r * 0.8, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Obstacle class (trees)
  class Obstacle {
    constructor(x) {
      this.x = x;
      this.topHeight = Math.random() * (height / 2 - gapHeight / 2 - 40) + 40;
      this.bottomY = this.topHeight + gapHeight;
      this.passed = false;
    }
    draw() {
      // Tree trunks
      ctx.fillStyle = '#5a3a1a';
      ctx.fillRect(this.x, this.topHeight - 35, obstacleWidth, 35);
      ctx.fillRect(this.x, this.bottomY, obstacleWidth, height - this.bottomY);

      // Top foliage (3 circles)
      drawCircle(this.x + obstacleWidth / 2, this.topHeight - 50, 35, '#2f6f2f');
      drawCircle(this.x + obstacleWidth / 2 - 25, this.topHeight - 30, 28, '#3b8a3b');
      drawCircle(this.x + obstacleWidth / 2 + 25, this.topHeight - 30, 28, '#3b8a3b');

      // Bottom foliage (3 circles)
      drawCircle(this.x + obstacleWidth / 2, this.bottomY + 15, 35, '#2f6f2f');
      drawCircle(this.x + obstacleWidth / 2 - 25, this.bottomY + 35, 28, '#3b8a3b');
      drawCircle(this.x + obstacleWidth / 2 + 25, this.bottomY + 35, 28, '#3b8a3b');
    }
    update() {
      this.x -= 3;
    }
  }

  // Draw background (houses and clouds)
  function drawBackground() {
    // Houses base line
    const baseY = height - 60;
    const houseColors = ['#565656', '#454545', '#6a6a6a', '#595959'];
    for (let i = 0; i < 6; i++) {
      let houseX = (i * 80 + frame * 1.5) % (width + 80) - 80;
      ctx.fillStyle = houseColors[i % houseColors.length];
      ctx.beginPath();
      ctx.moveTo(houseX, baseY);
      ctx.lineTo(houseX + 40, baseY - 45);
      ctx.lineTo(houseX + 80, baseY);
      ctx.closePath();
      ctx.fill();

      // Windows
      ctx.fillStyle = '#222';
      for (let w = 0; w < 3; w++) {
        for (let hW = 0; hW < 2; hW++) {
          ctx.fillRect(houseX + 12 + w * 13, baseY - 40 + hW * 18, 9, 9);
        }
      }
    }

    // Clouds (white, soft)
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    drawCloud((frame * 0.6) % (width + 140) - 140, 90);
    drawCloud(((frame * 0.6) + 280) % (width + 140) - 140, 130);
  }

  // Draw cloud shape
  function drawCloud(x, y) {
    ctx.beginPath();
    ctx.ellipse(x, y, 32, 22, 0, 0, 2 * Math.PI);
    ctx.ellipse(x + 34, y + 12, 32, 28, 0, 0, 2 * Math.PI);
    ctx.ellipse(x + 68, y, 32, 22, 0, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Collision detection function
  function collision(h, obs) {
    if (h.x + h.radius > obs.x && h.x - h.radius < obs.x + obstacleWidth) {
      if (h.y - h.radius < obs.topHeight || h.y + h.radius > obs.bottomY) {
        return true;
      }
    }
    if (h.y + h.radius > height || h.y - h.radius < 0) {
      return true;
    }
    return false;
  }

  // Reset game function
  function resetGame() {
    obstacles = [];
    frame = 0;
    score = 0;
    heart.y = height / 2;
    heart.vy = 0;
    gameOver = false;
    messageDiv.style.display = 'none';
    scoreDiv.textContent = score;
    loop();
  }

  // Jump function on input
  function jump() {
    if (gameOver) {
      resetGame();
    } else {
      heart.vy = jumpPower;
      heart.pulseScale = 1.25;
      heart.pulseDir = -1;
    }
  }

  // Input listeners
  window.addEventListener('mousedown', jump);
  window.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  }, {passive: false});

  // Main game loop
  function loop() {
    frame++;

    ctx.clearRect(0, 0, width, height);
    drawBackground();

    // Create new obstacles
    if (frame % obstacleSpacing === 0) {
      obstacles.push(new Obstacle(width));
    }

    // Update and draw obstacles
    obstacles.forEach(obs => {
      obs.update();
      obs.draw();

      // Check for passing obstacle for score
      if (!obs.passed && obs.x + obstacleWidth < heart.x) {
        score++;
        scoreDiv.textContent = score;
        obs.passed = true;
      }

      // Collision detection
      if (collision(heart, obs)) {
        gameOver = true;
      }
    });

    // Remove offscreen obstacles
    obstacles = obstacles.filter(obs => obs.x + obstacleWidth > 0);

    // Update heart physics
    if (!gameOver) {
      heart.vy += gravity;
      heart.y += heart.vy;

      // Heart pulse animation
      heart.pulseScale += heart.pulseSpeed * heart.pulseDir;
      if (heart.pulseScale > 1.15) heart.pulseDir = -1;
      if (heart.pulseScale < 1) heart.pulseDir = 1;
    }

    // Draw heart
    drawHeart(heart.x, heart.y, heart.pulseScale, '#d42b3f');

    // If game over show message
    if (gameOver) {
      messageDiv.style.display = 'block';
    }

    requestAnimationFrame(loop);
  }

  // Start game loop
  loop();
})();
</script>
</body>
</html>

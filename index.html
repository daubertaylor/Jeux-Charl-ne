<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Flappy Cœur - style cartoon</title>
<style>
  :root{
    --accent:#d91c46; /* coeur rouge */
    --bg-sky:#9fd9ff;
    --bg-horizon:#72c9ff;
    --wood1:#a9743a;
    --wood2:#6b451f;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-sky),var(--bg-horizon));-webkit-font-smoothing:antialiased;}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;overflow:hidden;display:flex;align-items:center;justify-content:center;}
  #gameCanvas{display:block; border-radius:18px; box-shadow:0 18px 50px rgba(20,30,40,0.25); touch-action:none; background:transparent;}
  #ui {
    position:fixed; left:50%; transform:translateX(-50%); top:18px; z-index:30; text-align:center;
    color:#063649; text-shadow:0 1px 0 rgba(255,255,255,0.3);
    pointer-events:none;
  }
  #score { font-weight:700; font-size:20px; pointer-events:none; background: rgba(255,255,255,0.25); padding:6px 12px; border-radius:12px; display:inline-block;}
  #message {
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:40;
    width:90%; max-width:480px; background:rgba(255,255,255,0.97); border-radius:16px; padding:18px;
    box-shadow:0 8px 30px rgba(0,0,0,0.25); display:none; text-align:center; color:var(--wood2);
  }
  #message p{margin:8px 0; font-size:18px;}
  #restartBtn{
    margin-top:10px; appearance:none; -webkit-appearance:none;
    background:var(--accent); color:white; border:none; padding:10px 18px; border-radius:12px;
    font-weight:700; font-size:16px; cursor:pointer;
  }
  /* small helper for debug (hidden normally) */
  .hidden{display:none;}
</style>
</head>
<body>
  <div id="ui"><div id="score">Score: 0</div></div>
  <canvas id="gameCanvas"></canvas>

  <div id="message" role="dialog" aria-live="polite">
    <p><strong>C’est pas grave mon amour ❤️</strong></p>
    <p>Chaque tentative te rapproche plus près du ciel ☁️✨</p>
    <button id="restartBtn">Rejouer</button>
  </div>

<script>
(() => {
  // -------------------------
  // Setup canvas full screen
  // -------------------------
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', {alpha:false});
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');

  function resizeCanvas(){
    // fill viewport with some margin so rounded corners are visible
    const margin = 0; // set >0 if you want border around canvas
    canvas.width = Math.max(360, Math.floor(window.innerWidth - margin*2));
    canvas.height = Math.max(600, Math.floor(window.innerHeight - margin*2));
    // scale factor for assets
    scale = canvas.width / 390; // base width 390 for consistent sizing
  }
  window.addEventListener('resize', resizeCanvas);
  let scale = 1;
  resizeCanvas();

  // -------------------------
  // Game state
  // -------------------------
  let frames = 0;
  let obstacles = [];
  let clouds = [];
  let particles = [];
  let score = 0;
  let running = true;
  let gameOver = false;

  // parameters (tweak for feel)
  const GRAVITY = 0.5;
  const FLAP = -10 * 1.05;
  const OB_SPEED = 3.8;
  const GAP = Math.round(150 * scale);
  const OB_W = Math.round(78 * scale);

  // -------------------------
  // Background parallax layers
  // -------------------------
  const mountains = [
    {x:0, y:canvas.height*0.6, w:canvas.width*0.9, h:120*scale, speed:0.15},
    {x:canvas.width*0.2, y:canvas.height*0.67, w:canvas.width*0.8, h:90*scale, speed:0.25}
  ];

  function initClouds(){
    clouds = [];
    const count = Math.max(4, Math.round(6*scale));
    for(let i=0;i<count;i++){
      clouds.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height*0.45,
        scale:0.6 + Math.random()*0.9,
        speed: 0.3 + Math.random()*0.8
      });
    }
  }
  initClouds();

  // -------------------------
  // Player heart (red)
  // -------------------------
  const player = {
    x: Math.round(canvas.width * 0.22),
    y: Math.round(canvas.height * 0.45),
    vy: 0,
    radius: Math.round(18 * scale),
    draw() {
      // cartoon heart with shading and small beat
      ctx.save();
      const t = frames / 10;
      const beat = 1 + 0.03 * Math.sin(t);
      ctx.translate(this.x, this.y);
      ctx.scale(beat, beat);
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.beginPath();
      ctx.ellipse(0, this.radius+10, this.radius*1.1, this.radius*0.6, 0, 0, Math.PI*2);
      ctx.fill();
      // main heart
      ctx.fillStyle = '#d91c46';
      ctx.shadowColor = 'rgba(217,28,70,0.7)';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      const r = this.radius;
      ctx.moveTo(0, 0);
      ctx.arc(-r*0.5, -r*0.5, r*0.6, 0, Math.PI*2);
      ctx.arc(r*0.4, -r*0.55, r*0.6, 0, Math.PI*2);
      ctx.moveTo(-r, -r*0.1);
      ctx.quadraticCurveTo(0, r*1.2, r, -r*0.1);
      ctx.fill();
      // small highlight
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.beginPath();
      ctx.ellipse(-r*0.2, -r*0.55, r*0.25, r*0.12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    },
    update() {
      this.vy += GRAVITY;
      this.y += this.vy;
      // clamp
      if(this.y + this.radius > canvas.height - 6){ this.y = canvas.height - 6 - this.radius; this.vy = 0; gameOver = true; }
      if(this.y - this.radius < 6){ this.y = 6 + this.radius; this.vy = 0; }
    },
    flap() { this.vy = FLAP; }
  };

  // -------------------------
  // Obstacles (wooden carved pillars)
  // -------------------------
  function spawnObstacle(){
    const minTop = Math.round(60 * scale);
    const maxTop = Math.round(canvas.height - GAP - 120*scale);
    const top = Math.random()*(maxTop-minTop) + minTop;
    obstacles.push({
      x: canvas.width + 20,
      top: top,
      bottom: top + GAP,
      w: OB_W,
      passed: false
    });
  }

  // draw wood pillar with grain and knots
  function drawWoodPillar(x,y,h,w){
    // base rounded rect
    const radius = 8 * scale;
    ctx.save();
    // shadow
    ctx.shadowColor = 'rgba(30,20,10,0.25)';
    ctx.shadowBlur = 12;
    // wood gradient
    const grad = ctx.createLinearGradient(x,y,x+w,y+h);
    grad.addColorStop(0, '#c9925a');
    grad.addColorStop(0.5, '#a9743a');
    grad.addColorStop(1, '#7a4f2a');
    ctx.fillStyle = grad;
    // rect
    roundRect(ctx, x, y, w, h, radius, true, false);
    ctx.shadowBlur = 0;
    // wood lines (grain)
    ctx.strokeStyle = 'rgba(120,70,30,0.12)';
    ctx.lineWidth = Math.max(1, 1.2*scale);
    for(let i=0;i<6;i++){
      const yy = y + (i/6)*h + Math.sin((x+i*20)/50)*7*scale;
      ctx.beginPath();
      ctx.moveTo(x+6*scale, yy);
      ctx.quadraticCurveTo(x + w*0.5, yy + 6*scale, x + w - 6*scale, yy - 6*scale);
      ctx.stroke();
    }
    // small knots
    ctx.fillStyle = 'rgba(60,30,20,0.18)';
    for(let i=0;i<3;i++){
      const kx = x + (0.2 + Math.random()*0.6)*w;
      const ky = y + Math.random()*h;
      ctx.beginPath();
      ctx.ellipse(kx, ky, 6*scale, 4*scale, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // rounded rectangle helper
  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if(typeof r === 'undefined') r=5;
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  // -------------------------
  // Particles (sparkles on pass)
  // -------------------------
  function spawnParticles(cx, cy, color){
    for(let i=0;i<18;i++){
      particles.push({
        x:cx, y:cy,
        vx:(Math.random()-0.5)*4*scale,
        vy:(Math.random()-1.5)*3*scale,
        life: 30 + Math.random()*20,
        size: 2 + Math.random()*3*scale,
        color: color
      });
    }
  }

  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.06*scale;
      p.life--;
      if(p.life<=0) particles.splice(i,1);
    }
  }
  function drawParticles(){
    particles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life/50);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, p.size, p.size*0.7, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    });
  }

  // -------------------------
  // Collision circle-rect
  // -------------------------
  function circleRectColl(cx, cy, cr, rx, ry, rw, rh){
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < (cr*cr);
  }

  // -------------------------
  // Game loop
  // -------------------------
  function resetGame(){
    frames = 0;
    obstacles = [];
    particles = [];
    clouds.forEach((c,i)=>{ c.x = Math.random()*canvas.width; c.y = Math.random()*canvas.height*0.45; });
    score = 0;
    scoreEl.innerText = 'Score: 0';
    player.x = Math.round(canvas.width * 0.22);
    player.y = Math.round(canvas.height * 0.45);
    player.vy = 0;
    gameOver = false;
    running = true;
    // spawn first obstacles spaced
    for(let i=0;i<2;i++){
      spawnObstacle();
      obstacles[obstacles.length-1].x += i * (canvas.width*0.5);
    }
    messageEl.style.display = 'none';
    loop();
  }

  function drawBackground(){
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#a7dbff');
    g.addColorStop(0.6, '#9fd6ff');
    g.addColorStop(1, '#dff6ff');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // distant mountains (soft shadows)
    mountains.forEach((m, idx) => {
      const offset = (frames * m.speed) % canvas.width;
      const baseY = m.y;
      ctx.save();
      ctx.fillStyle = idx === 0 ? '#7a8fb2' : '#9ca9c6';
      ctx.globalAlpha = idx === 0 ? 1 : 0.9;
      ctx.beginPath();
      ctx.moveTo(-canvas.width + offset, canvas.height);
      ctx.lineTo(-canvas.width*0.2 + offset, baseY - 60*scale);
      ctx.lineTo(canvas.width*0.3 + offset, baseY - 20*scale);
      ctx.lineTo(canvas.width + offset, canvas.height);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });

    // mid ground trees / hills - subtle
    ctx.save();
    ctx.translate(0, canvas.height*0.65);
    for(let i=0;i<6;i++){
      const tx = (i*canvas.width/6 - (frames*0.35)%canvas.width);
      const h = 40*scale + (i%2)*20*scale;
      drawTree(tx + canvas.width/6, 10*scale, h);
    }
    ctx.restore();

    // clouds
    clouds.forEach(c => {
      ctx.save();
      ctx.globalAlpha = 0.95;
      drawCloud(c.x, c.y, c.scale);
      ctx.restore();
    });
  }

  function drawCloud(x,y,s){
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.ellipse(x, y, 40*s, 24*s, 0, 0, Math.PI*2);
    ctx.ellipse(x+30*s, y-6*s, 34*s, 20*s, 0, 0, Math.PI*2);
    ctx.ellipse(x+55*s, y, 40*s, 24*s, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawTree(x, offsetY, h){
    // simple stylized tree
    ctx.save();
    ctx.translate(x, offsetY);
    // trunk
    ctx.fillStyle = '#6b3f1b';
    ctx.fillRect(-6*scale, 0, 12*scale, h*0.6);
    // leaves
    ctx.fillStyle = '#0b7a3b';
    ctx.beginPath();
    ctx.ellipse(0, -10*scale, 32*scale, 28*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawObstacles(){
    obstacles.forEach(o=>{
      // top pillar
      drawWoodPillar(o.x, 0, o.top, o.w);
      // bottom pillar
      drawWoodPillar(o.x, o.bottom, canvas.height - o.bottom, o.w);
      // little highlight stripe
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(o.x + o.w*0.08, o.top*0.1, o.w*0.2, Math.max(10, o.top*0.4));
      ctx.fillRect(o.x + o.w*0.72, o.bottom + (canvas.height - o.bottom)*0.1, o.w*0.16, Math.max(10, (canvas.height - o.bottom)*0.4));
      ctx.restore();
    });
  }

  function update(){
    frames++;
    // move clouds a bit
    clouds.forEach(c => { c.x -= c.speed; if(c.x < -150) c.x = canvas.width + 150; });

    // move obstacles
    obstacles.forEach((o, idx) => {
      o.x -= OB_SPEED;
      // score check
      if(!o.passed && o.x + o.w < player.x - player.radius){
        o.passed = true;
        score++;
        scoreEl.innerText = 'Score: ' + score;
        // particles celebration
        spawnParticles(player.x, player.y, 'rgba(217,28,70,0.95)');
      }
    });
    // remove offscreen
    if(obstacles.length && obstacles[0].x + obstacles[0].w < -50) obstacles.shift();

    // spawn
    if(frames % Math.max(75, Math.round(90/scale)) === 0){
      spawnObstacle();
    }

    // update particles
    updateParticles();

    // update player physics
    player.update();

    // check collisions
    for(const o of obstacles){
      // check top rect
      if(circleRectColl(player.x, player.y, player.radius, o.x, 0, o.w, o.top)){
        gameOver = true;
      }
      // bottom rect
      if(circleRectColl(player.x, player.y, player.radius, o.x, o.bottom, o.w, canvas.height - o.bottom)){
        gameOver = true;
      }
    }

    // if hit ground or ceiling, handled in player.update() sets gameOver true
    if(gameOver){ running = false; messageEl.style.display = 'block'; }
  }

  function render(){
    drawBackground();
    drawObstacles();
    player.draw();
    drawParticles();
  }

  function loop(){
    if(!running) return;
    update();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    render();
    requestAnimationFrame(loop);
  }

  // -------------------------
  // Input handling (touch/mouse)
  // -------------------------
  function onTap(e){
    e.preventDefault();
    if(!gameOver){
      player.flap();
    } else {
      // if game over and user taps canvas, restart
      resetGame();
    }
  }
  canvas.addEventListener('touchstart', onTap, {passive:false});
  canvas.addEventListener('mousedown', onTap);

  // restart button
  restartBtn.addEventListener('click', resetGame);

  // -------------------------
  // Start
  // -------------------------
  // ensure size-dependent values update
  function start(){
    resizeCanvas();
    // reinit player & background dependent things
    player.radius = Math.round(18 * scale);
    player.x = Math.round(canvas.width * 0.22);
    player.y = Math.round(canvas.height * 0.45);
    mountains[0].y = canvas.height * 0.6;
    mountains[1].y = canvas.height * 0.68;
    initClouds();
    resetGame();
  }

  start();

  // expose debug (optional)
  window.__game = { reset: resetGame, spawn: spawnObstacle };

})();
</script>
</body>
</html>

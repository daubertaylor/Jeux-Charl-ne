<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Flappy Cœur Moderne</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap');
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
    display: flex; justify-content: center; align-items: center;
  }
  #game {
    display: block;
    background: linear-gradient(180deg, #d0e6ff 0%, #8ab4f8 100%);
    border-radius: 24px;
    box-shadow: 0 12px 24px rgba(34, 60, 80, 0.3);
    touch-action: none;
  }
  #score {
    position: fixed;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 0 6px rgba(255,0,80,0.8);
    user-select: none;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.9);
    padding: 30px 40px;
    border-radius: 28px;
    box-shadow: 0 8px 30px rgba(255, 0, 80, 0.4);
    color: #ff004f;
    font-weight: 600;
    font-size: 22px;
    text-align: center;
    line-height: 1.4;
    user-select: none;
    display: none;
    max-width: 90vw;
  }
  #restartBtn {
    margin-top: 20px;
    background: #ff004f;
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 18px;
    font-size: 18px;
    cursor: pointer;
    font-weight: 700;
    box-shadow: 0 6px 12px rgba(255, 0, 79, 0.7);
    transition: background 0.3s ease;
  }
  #restartBtn:hover {
    background: #ff3366;
  }
  /* Heart shape */
  .heart {
    position: absolute;
    width: 40px;
    height: 36px;
    background: #ff004f;
    transform: rotate(-45deg);
    filter: drop-shadow(0 0 6px #ff004f99);
    animation: beat 1.2s infinite ease-in-out;
  }
  .heart::before,
  .heart::after {
    content: "";
    position: absolute;
    width: 40px;
    height: 36px;
    background: #ff004f;
    border-radius: 50%;
  }
  .heart::before {
    top: -20px;
    left: 0;
  }
  .heart::after {
    left: 20px;
    top: 0;
  }
  @keyframes beat {
    0%, 100% { transform: rotate(-45deg) scale(1); }
    50% { transform: rotate(-45deg) scale(1.1); }
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game"></canvas>
<div id="message">
  C’est pas grave mon amour ❤️<br />
  Chaque tentative te rapproche plus près du ciel ☁️✨<br />
  <button id="restartBtn">Rejouer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');

  // Fullscreen canvas with some margin for rounded edges on iOS
  function resize() {
    canvas.width = window.innerWidth * 0.95;
    canvas.height = window.innerHeight * 0.95;
  }
  window.addEventListener('resize', resize);
  resize();

  // Game variables
  const gravity = 0.55;
  const flapPower = -11;
  const obstacleSpeed = 4.5;
  const gapHeight = 160;
  const obstacleWidth = 70;

  let frames = 0;
  let score = 0;
  let gameOver = false;

  // Heart player
  const heart = {
    x: canvas.width * 0.2,
    y: canvas.height / 2,
    radius: 20,
    velocity: 0,
    draw() {
      // Heart shape using canvas path (simplified)
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(1,1);
      ctx.rotate(-Math.PI / 4);
      ctx.fillStyle = '#ff004f';
      ctx.shadowColor = '#ff004faa';
      ctx.shadowBlur = 12;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, -this.radius/2, this.radius/2, 0, Math.PI, true);
      ctx.arc(this.radius/2, -this.radius/2, this.radius/2, 0, Math.PI, true);
      ctx.lineTo(0, this.radius);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    },
    update() {
      this.velocity += gravity;
      this.y += this.velocity;
      if (this.y + this.radius > canvas.height) {
        this.y = canvas.height - this.radius;
        this.velocity = 0;
      }
      if (this.y - this.radius < 0) {
        this.y = this.radius;
        this.velocity = 0;
      }
    },
    flap() {
      this.velocity = flapPower;
    },
    getBounds() {
      return {
        left: this.x - this.radius,
        right: this.x + this.radius,
        top: this.y - this.radius,
        bottom: this.y + this.radius,
      };
    }
  };

  // Obstacles array
  let obstacles = [];

  function createObstacle() {
    const minHeight = 50;
    const maxHeight = canvas.height - gapHeight - 50;
    const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
    obstacles.push({
      x: canvas.width + obstacleWidth,
      topHeight,
      bottomY: topHeight + gapHeight,
      width: obstacleWidth,
      passed: false,
      colorTop: `hsl(340, 90%, 65%)`,
      colorBottom: `hsl(350, 80%, 60%)`,
      shadowTop: 'rgba(255, 20, 60, 0.6)',
      shadowBottom: 'rgba(255, 30, 70, 0.7)',
    });
  }

  // Collision detection
  function isColliding(rect, circle) {
    // Closest point on rect to circle center
    let closestX = Math.max(rect.left, Math.min(circle.x, rect.right));
    let closestY = Math.max(rect.top, Math.min(circle.y, rect.bottom));
    let dx = circle.x - closestX;
    let dy = circle.y - closestY;
    return (dx * dx + dy * dy) < (circle.radius * circle.radius);
  }

  function drawObstacle(obstacle) {
    // Draw top rectangle with gradient and shadow
    let gradTop = ctx.createLinearGradient(obstacle.x, 0, obstacle.x + obstacle.width, 0);
    gradTop.addColorStop(0, obstacle.colorTop);
    gradTop.addColorStop(1, '#fff0f3');
    ctx.fillStyle = gradTop;
    ctx.shadowColor = obstacle.shadowTop;
    ctx.shadowBlur = 14;
    ctx.fillRect(obstacle.x, 0, obstacle.width, obstacle.topHeight);

    // Draw bottom rectangle
    let gradBottom = ctx.createLinearGradient(obstacle.x, canvas.height, obstacle.x + obstacle.width, canvas.height);
    gradBottom.addColorStop(0, obstacle.colorBottom);
    gradBottom.addColorStop(1, '#fff0f3');
    ctx.fillStyle = gradBottom;
    ctx.shadowColor = obstacle.shadowBottom;
    ctx.shadowBlur = 14;
    ctx.fillRect(obstacle.x, obstacle.bottomY, obstacle.width, canvas.height - obstacle.bottomY);

    // Reset shadow
    ctx.shadowBlur = 0;
  }

  // Game over handler
  function endGame() {
    gameOver = true;
    messageEl.style.display = 'block';
  }

  // Restart game
  restartBtn.addEventListener('click', () => {
    gameOver = false;
    messageEl.style.display = 'none';
    score = 0;
    scoreEl.textContent = `Score: 0`;
    obstacles = [];
    heart.y = canvas.height / 2;
    heart.velocity = 0;
    frames = 0;
    createObstacle(); // spawn first obstacle
    gameLoop();
  });

  // Game loop
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background subtle animated (moving gradient)
    const bgGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    const color1 = `hsl(210, 90%, ${50 + 10 * Math.sin(frames * 0.02)}%)`;
    const color2 = `hsl(220, 80%, ${70 + 10 * Math.cos(frames * 0.015)}%)`;
    bgGradient.addColorStop(0, color1);
    bgGradient.addColorStop(1, color2);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw obstacles
    obstacles.forEach(obstacle => {
      drawObstacle(obstacle);
      obstacle.x -= obstacleSpeed;

      // Check score
      if (!obstacle.passed && obstacle.x + obstacle.width < heart.x) {
        score++;
        scoreEl.textContent = `Score: ${score}`;
        obstacle.passed = true;
        // Particles effect could be added here later
      }
    });

    // Remove off-screen obstacles
    obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

    // Create new obstacles every 100 frames
    if (frames % 100 === 0) {
      createObstacle();
    }

    // Update & draw heart
    heart.update();
    heart.draw();

    // Collision detection
    for (const obstacle of obstacles) {
      const rectTop = { left: obstacle.x, right: obstacle.x + obstacle.width, top: 0, bottom: obstacle.topHeight };
      const rectBottom = { left: obstacle.x, right: obstacle.x + obstacle

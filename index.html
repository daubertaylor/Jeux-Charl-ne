<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Le Panier d'Amour pour Charl√®ne ‚ù§Ô∏è</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    width: 100%; height: 100%;
    background: #ffb6c1;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  #gameCanvas {
    display: block;
    background: linear-gradient(180deg, #ff9a9e, #fad0c4);
    width: 100vw;
    height: 100vh;
  }
  #scoreDisplay {
    position: fixed;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    font-weight: 700;
    color: #6b0f1a;
    text-shadow: 1px 1px 3px #fff0f0;
    z-index: 10;
    user-select: none;
  }
  #messageOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(255, 192, 203, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: #6b0f1a;
    font-size: 30px;
    font-weight: 700;
    text-align: center;
    padding: 0 20px;
    z-index: 20;
    user-select: none;
    display: none;
  }
  #messageOverlay button {
    margin-top: 30px;
    font-size: 22px;
    padding: 12px 30px;
    background: #ff5f6d;
    border: none;
    border-radius: 12px;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(255,95,109,0.7);
    transition: background 0.3s ease;
  }
  #messageOverlay button:hover {
    background: #ff3941;
  }
</style>
</head>
<body>

<div id="scoreDisplay">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<div id="messageOverlay">
  <div>üíî Oh non, Charl√®ne ! Ton panier a manqu√© trop de c≈ìurs... üíî</div>
  <div>Mais chaque tentative te rapproche plus pr√®s du ciel !</div>
  <button id="restartBtn">Recommencer ‚ù§Ô∏è</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const messageOverlay = document.getElementById('messageOverlay');
  const restartBtn = document.getElementById('restartBtn');

  // Resize canvas to full viewport
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Game variables
  let score = 0;
  let missedHearts = 0;
  const maxMissed = 5;

  // Panier controlled by player
  const basket = {
    width: 120,
    height: 40,
    x: canvas.width / 2 - 60,
    y: canvas.height - 60,
    color: '#ff5f6d',
    targetX: null,
    draw() {
      // Basket base
      ctx.fillStyle = this.color;
      ctx.shadowColor = '#ff5f6d';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y + this.height);
      ctx.bezierCurveTo(this.x + this.width / 2, this.y - 30, this.x + this.width, this.y + this.height, this.x + this.width, this.y + this.height);
      ctx.fill();

      // Basket rim
      ctx.strokeStyle = '#8b2833';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y + this.height);
      ctx.quadraticCurveTo(this.x + this.width / 2, this.y + this.height - 10, this.x + this.width, this.y + this.height);
      ctx.stroke();
    },
    update() {
      if (this.targetX !== null) {
        const dx = this.targetX - this.x;
        this.x += dx * 0.15;
        // Clamp basket inside canvas
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
      }
    }
  };

  // Heart objects falling down
  class Heart {
    constructor() {
      this.size = 40 + Math.random() * 15;
      this.x = Math.random() * (canvas.width - this.size);
      this.y = -this.size - (Math.random() * 300);
      this.speed = 2 + Math.random() * 2;
      this.rotation = Math.random() * Math.PI * 2;
      this.rotationSpeed = 0.02 + Math.random() * 0.03;
      this.caught = false;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x + this.size/2, this.y + this.size/2);
      ctx.rotate(this.rotation);
      ctx.fillStyle = '#ff4d6d';
      ctx.shadowColor = '#ff4d6d';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(0, -this.size / 3);
      ctx.bezierCurveTo(this.size / 2, -this.size, this.size, -this.size / 4, 0, this.size / 1.5);
      ctx.bezierCurveTo(-this.size, -this.size / 4, -this.size / 2, -this.size, 0, -this.size / 3);
      ctx.fill();
      ctx.restore();
    }
    update() {
      this.y += this.speed;
      this.rotation += this.rotationSpeed;
    }
  }

  // Cloud obstacles
  class Cloud {
    constructor() {
      this.size = 70 + Math.random() * 30;
      this.x = Math.random() * (canvas.width - this.size);
      this.y = -this.size - (Math.random() * 600);
      this.speed = 1 + Math.random() * 1.5;
    }
    draw() {
      ctx.fillStyle = '#b0bec5';
      ctx.shadowColor = '#90a4ae';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      const x = this.x;
      const y = this.y;
      const s = this.size;
      ctx.ellipse(x + s * 0.25, y + s * 0.5, s * 0.3, s * 0.25, 0, 0, 2 * Math.PI);
      ctx.ellipse(x + s * 0.5, y + s * 0.35, s * 0.4, s * 0.35, 0, 0, 2 * Math.PI);
      ctx.ellipse(x + s * 0.75, y + s * 0.5, s * 0.3, s * 0.25, 0, 0, 2 * Math.PI);
      ctx.fill();
    }
    update() {
      this.y += this.speed;
    }
  }

  const hearts = [];
  const clouds = [];

  // Generate hearts and clouds periodically
  function spawnObjects() {
    if (hearts.length < 10) hearts.push(new Heart());
    if (clouds.length < 5 && Math.random() < 0.02) clouds.push(new Cloud());
  }

  // Check collision basket <-> heart/cloud
  function isColliding(a, b) {
    return !(
      a.x > b.x + b.size ||
      a.x + a.width < b.x ||
      a.y > b.y + b.size ||
      a.y + a.height < b.y
    );
  }

  // More precise circle-rectangle collision for hearts & basket
  function circleRectCollision(circleX, circleY, radius, rectX, rectY, rectW, rectH) {
    const distX = Math.abs(circleX - rectX - rectW / 2);
    const distY = Math.abs(circleY - rectY - rectH / 2);

    if (distX > (rectW / 2 + radius)) { return false; }
    if (distY > (rectH / 2 + radius)) { return false; }

    if (distX <= (rectW / 2)) { return true; }
    if (distY <= (rectH / 2)) { return true; }

    const dx = distX - rectW / 2;
    const dy = distY - rectH / 2;
    return (dx * dx + dy * dy <= (radius * radius));
  }

  // Update background gradient based on score
  function updateBackground() {
    const maxScore = 50;
    const progress = Math.min(score / maxScore, 1);
    const startColor = [255, 154, 158]; // #ff9a9e
    const endColor = [253, 224, 221];   // #fddedd
    const r = Math.round(startColor[0] + (endColor[0] - startColor[0]) * progress);
    const g = Math.round(startColor[1] + (endColor[1] - startColor[1]) * progress);
    const b = Math.round(startColor[2] + (endColor[2] - startColor[2]) * progress);
    document.body.style.background = `rgb(${r},${g},${b})`;
  }

  // Game over display
  function showGameOver() {
    messageOverlay.style.display = 'flex';
  }
  function hideGameOver() {
    messageOverlay.style.display = 'none';
  }

  // Game loop
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateBackground();

    basket.update();
    basket.draw();

    hearts.forEach((heart, i) => {
      heart.update();
      heart.draw();

      // Check if caught
      if (!heart.caught && circleRectCollision(
        heart.x + heart.size / 2,
        heart.y + heart.size / 2,
        heart.size / 2,
        basket.x, basket.y, basket.width, basket.height
      )) {
        heart.caught = true;
        score++;
        scoreDisplay.textContent = `Score: ${score}`;
      }

      // Remove hearts that fell below the screen and count misses
      if (heart.y - heart.size > canvas.height && !heart.caught) {
        hearts.splice(i, 1);
        missedHearts++;
        if (missedHearts >= maxMissed) {
          gameOver = true;
          showGameOver();
        }
      }
      if (heart.y - heart.size > canvas.height) {
        hearts.splice(i, 1);
      }
    });

    clouds.forEach((cloud, i) => {
      cloud.update();
      cloud.draw();

      // Collision cloud and basket = game over
      if (cloud.y + cloud.size > basket.y &&
          cloud.y < basket.y + basket.height &&
          cloud.x + cloud.size > basket.x &&
          cloud.x < basket.x + basket.width) {
        gameOver = true;
        showGameOver();
      }

      if (cloud.y - cloud.size > canvas.height) {
        clouds.splice(i, 1);
      }
    });

    spawnObjects();

    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    }
  }

  // Control basket with touch and mouse
  function onPointerMove(e) {
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    basket.targetX = clientX - basket.width / 2;
  }
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('touchmove', onPointerMove);

  // Restart game logic
  function restartGame() {
    score = 0;
    missedHearts = 0;
    gameOver = false;
    hearts.length = 0;
    clouds.length = 0;
    scoreDisplay.textContent = `Score: ${score}`;
    hideGameOver();
    gameLoop();
  }

  restartBtn.addEventListener('click', restartGame);

  let gameOver = false;
  restartGame();

})();
</script>

</body>
</html>

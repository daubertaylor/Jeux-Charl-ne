<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Heart ForÃªt</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  html, body {
    margin:0; padding:0; height:100%;
    background: linear-gradient(to top, #317d49 0%, #a0d8ef 90%);
    font-family: 'Baloo 2', cursive;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    display: block;
    background: transparent;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
  }
  #score {
    position: fixed;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    font-size: 2.5rem;
    color: #ff4c62;
    text-shadow: 0 0 10px #ff7392;
    z-index: 10;
  }
  #message {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 40, 25, 0.9);
    color: #f0f7e8;
    padding: 2em 2.5em;
    border-radius: 20px;
    text-align: center;
    font-size: 1.3rem;
    display: none;
    z-index: 20;
    box-shadow: 0 0 20px #84c885;
  }
  #message button {
    margin-top: 1.2em;
    background: #4caf50;
    border: none;
    border-radius: 12px;
    padding: 0.8em 2.2em;
    font-weight: bold;
    color: white;
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.25);
  }
  #message button:hover {
    background: #388e3c;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="score">0</div>
<div id="message">
  <p>Ce nâ€™est pas grave mon amour ðŸ’”<br>Tu as tout donnÃ©, je suis fier de toi.</p>
  <button id="restartBtn">Recommencer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreDiv = document.getElementById('score');
  const messageDiv = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');

  let W, H;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * devicePixelRatio;
    canvas.height = H * devicePixelRatio;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  resize();
  window.addEventListener('resize', resize);

  // Game parameters
  const gravity = 0.6;
  const jumpPower = -10;
  const obstacleWidth = 70;
  const gapHeight = 150;
  const speed = 3;
  const heartRadius = 25;

  // Heart player
  const heart = {
    x: W / 4,
    y: H / 2,
    vy: 0,
    pulse: 0,
  };

  let obstacles = [];
  let frameCount = 0;
  let score = 0;
  let running = true;

  // Obstacles class (trees)
  class Obstacle {
    constructor(x) {
      this.x = x;
      this.topHeight = 80 + Math.random() * (H - gapHeight - 160);
      this.bottomHeight = H - this.topHeight - gapHeight;
    }
    update() {
      this.x -= speed;
    }
    draw() {
      drawTree(this.x, 0, this.topHeight);
      ctx.save();
      ctx.translate(this.x, H);
      ctx.scale(1, -1);
      drawTree(0, 0, this.bottomHeight);
      ctx.restore();
    }
    collides(cx, cy, cr) {
      // Collision with trunks approximated as rectangles
      if (cx + cr > this.x - 10 && cx - cr < this.x + 10) {
        if (cy - cr < this.topHeight) return true;
        if (cy + cr > H - this.bottomHeight) return true;
      }
      return false;
    }
  }

  function addObstacle() {
    const lastX = obstacles.length ? obstacles[obstacles.length - 1].x : W + 150;
    obstacles.push(new Obstacle(lastX + 250));
  }

  // Draw heart shape, pulsating
  function drawHeart(x, y, radius) {
    ctx.save();
    ctx.translate(x, y);
    const scalePulse = 1 + 0.05 * Math.sin(heart.pulse);
    ctx.scale(scalePulse, scalePulse);

    ctx.beginPath();
    const topCurveHeight = radius * 0.3;
    ctx.moveTo(0, topCurveHeight);
    ctx.bezierCurveTo(0, 0, -radius / 2, 0, -radius / 2, topCurveHeight);
    ctx.bezierCurveTo(-radius / 2, radius / 2, 0, radius * 0.75, 0, radius);
    ctx.bezierCurveTo(0, radius * 0.75, radius / 2, radius / 2, radius / 2, topCurveHeight);
    ctx.bezierCurveTo(radius / 2, 0, 0, 0, 0, topCurveHeight);
    ctx.closePath();

    const grad = ctx.createRadialGradient(0, radius / 2, radius * 0.1, 0, radius / 2, radius);
    grad.addColorStop(0, '#ff4c62');
    grad.addColorStop(1, '#a80020');
    ctx.fillStyle = grad;

    ctx.shadowColor = 'rgba(255, 76, 98, 0.9)';
    ctx.shadowBlur = 15;

    ctx.fill();
    ctx.restore();
  }

  // Draw stylized tree (trunk + foliage)
  function drawTree(x, y, height) {
    ctx.save();
    ctx.translate(x, y);

    // Trunk
    ctx.fillStyle = '#4a2e0f';
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 5;
    ctx.fillRect(-10, 0, 20, height);

    // Foliage: 3 circles
    ctx.fillStyle = '#3a7d3c';
    ctx.shadowColor = 'rgba(20,60,15,0.5)';
    ctx.shadowBlur = 12;
    const r = 30;
    ctx.beginPath();
    ctx.ellipse(0, -r * 0.7, r, r * 0.8, 0, 0, Math.PI * 2);
    ctx.ellipse(-r, -r * 1.3, r, r, 0, 0, Math.PI * 2);
    ctx.ellipse(r, -r * 1.3, r, r, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Clouds data
  const clouds = [];
  for (let i = 0; i < 7; i++) {
    clouds.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.5,
      size: 40 + Math.random() * 60,
      speed: 0.3 + Math.random() * 0.5,
    });
  }
  function drawCloud(x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.shadowColor = 'rgba(200,200,210,0.8)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
    ctx.ellipse(size * 0.5, -size * 0.1, size * 0.55, size * 0.45, 0, 0, Math.PI * 2

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Cœur</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body, html { width: 100%; height: 100%; overflow: hidden; background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%); display: flex; justify-content: center; align-items: center; }
  canvas { display: block; background: #ffe6e6; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 100, 120, 0.5);}
  #score { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 24px; color: #ff2e63; font-weight: bold; text-shadow: 1px 1px 2px #fff;}
  #message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 28px; color: #ff2e63; background: #fff0f3; padding: 20px 30px; border-radius: 15px;
    box-shadow: 0 0 15px rgba(255, 46, 99, 0.7);
    text-align: center; display: none;
  }
  #restartBtn {
    margin-top: 15px;
    padding: 10px 25px;
    font-size: 18px;
    border: none;
    border-radius: 10px;
    background: #ff2e63;
    color: white;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(255, 46, 99, 0.6);
  }
  #restartBtn:hover {
    background: #ff5470;
  }
</style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="score">Score: 0</div>
  <div id="message">
    C’est pas grave mon amour ❤️<br />
    Chaque tentative te rapproche plus près du ciel ☁️✨<br />
    <button id="restartBtn">Rejouer</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Fullscreen canvas
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Game variables
  const gravity = 0.6;
  const lift = -12;
  let score = 0;
  let bestScore = 0;

  // Heart (player) properties
  const heart = {
    x: 50,
    y: canvas.height / 2,
    width: 40,
    height: 36,
    velocity: 0,
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(1.2, 1.2);
      ctx.fillStyle = '#ff2e63';
      ctx.shadowColor = '#ff2e63';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.bezierCurveTo(20, -40, 60, -15, 0, 40);
      ctx.bezierCurveTo(-60, -15, -20, -40, 0, -10);
      ctx.fill();
      ctx.restore();
    },
    update() {
      this.velocity += gravity;
      this.y += this.velocity;

      if (this.y + this.height / 2 > canvas.height) {
        this.y = canvas.height - this.height / 2;
        this.velocity = 0;
      }
      if (this.y - this.height / 2 < 0) {
        this.y = this.height / 2;
        this.velocity = 0;
      }
    },
    flap() {
      this.velocity = lift;
    },
    getBounds() {
      return {
        left: this.x - this.width / 2,
        right: this.x + this.width / 2,
        top: this.y - this.height / 2,
        bottom: this.y + this.height / 2,
      };
    }
  };

  // Obstacles properties
  const obstacleWidth = 60;
  const gapHeight = 180;
  const obstacleSpeed = 4;
  let obstacles = [];

  function createObstacle() {
    const topHeight = Math.random() * (canvas.height - gapHeight - 150) + 50;
    obstacles.push({
      x: canvas.width + obstacleWidth,
      topHeight,
      bottomY: topHeight + gapHeight,
      passed: false,
      color: `hsl(${Math.random() * 360}, 80%, 60%)`
    });
  }

  // Game state
  let gameOver = false;

  // Score display
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');

  // Game loop
  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw obstacles
    obstacles.forEach(obstacle => {
      ctx.fillStyle = obstacle.color;
      // top rect
      ctx.fillRect(obstacle.x, 0, obstacleWidth, obstacle.topHeight);
      // bottom rect
      ctx.fillRect(obstacle.x, obstacle.bottomY, obstacleWidth, canvas.height - obstacle.bottomY);
    });

    // Update obstacles position
    obstacles.forEach(obstacle => obstacle.x -= obstacleSpeed);

    // Remove off-screen obstacles
    obstacles = obstacles.filter(obstacle => obstacle.x + obstacleWidth > 0);

    // Add new obstacle every ~90 frames
    if (frames % 90 === 0) {
      createObstacle();
    }

    // Update and draw heart
    heart.update();
    heart.draw();

    // Check collisions
    obstacles.forEach(obstacle => {
      const hb = heart.getBounds();
      const insideX = hb.right > obstacle.x && hb.left < obstacle.x + obstacleWidth;
      const insideY = hb.top < obstacle.topHeight || hb.bottom > obstacle.bottomY;

      if (insideX && insideY) {
        endGame();
      }

      if (!obstacle.passed && obstacle.x + obstacleWidth < heart.x) {
        score++;
        obstacle.passed = true;
        scoreEl.textContent = `Score: ${score}`;
      }
    });

    if (heart.y + heart.height / 2 >= canvas.height) {
      endGame();
    }

    if (!gameOver) {
      frames++;
      requestAnimationFrame(gameLoop);
    }
  }

  function endGame() {
    gameOver = true;
    messageEl.style.display = 'block';
  }

  // Restart game
  restartBtn.addEventListener('click', () => {
    gameOver = false;
    messageEl.style.display = 'none';
    score = 0;
    scoreEl.textContent = `Score: 0`;
    obstacles = [];
    heart.y = canvas.height / 2;
    heart.velocity = 0;
    frames = 0;
    gameLoop();
  });

  // Control input
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') heart.flap();
  });
  window.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!gameOver) heart.flap();
  }, { passive: false });

  let frames = 0;
  gameLoop();
})();
</script>
</body>
</html>

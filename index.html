<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flappy Heart - Jeu pour toi ❤️</title>
<style>
  /* Reset et style de base */
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body, html {
    height: 100%;
    background: linear-gradient(to top, #87ceeb 0%, #f0f8ff 100%);
    overflow: hidden;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    user-select: none;
  }

  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  canvas {
    display: block;
    background: #a0d8f7;
  }

  /* Décor - ville cartoon */
  #background {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 35%;
    background: linear-gradient(to top, #465a78 0%, #758dbf 100%);
    box-shadow: inset 0 5px 15px rgba(0,0,0,0.2);
    z-index: 1;
  }

  .building {
    position: absolute;
    bottom: 0;
    background: #5c6a82;
    border: 3px solid #394a63;
    border-radius: 5px 5px 0 0;
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2);
  }

  /* Nuages */
  #clouds {
    position: absolute;
    top: 10%;
    width: 100%;
    height: 30%;
    pointer-events: none;
    z-index: 5;
  }

  .cloud {
    position: absolute;
    background: #fff;
    border-radius: 50%;
    opacity: 0.85;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
    animation: floatClouds linear infinite;
  }

  @keyframes floatClouds {
    0% {transform: translateX(-150px);}
    100% {transform: translateX(110vw);}
  }

  /* Message de fin */
  #messageBox {
    position: absolute;
    top: 40%;
    width: 100%;
    text-align: center;
    font-size: 1.8em;
    color: #d6366e;
    text-shadow: 1px 1px 2px #fff;
    display: none;
    z-index: 10;
  }

  /* Bouton rejouer */
  #restartBtn {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 1.2em;
    border: none;
    background: #d6366e;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 3px 6px #b32e61;
    transition: background 0.3s ease;
  }
  #restartBtn:hover {
    background: #a62b51;
  }

</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <div id="background"></div>
  <div id="clouds"></div>

  <div id="messageBox">
    <div>Ne t’inquiète pas, tu voleras plus haut la prochaine fois ! ❤️</div>
    <button id="restartBtn">Rejouer</button>
  </div>
</div>

<script>
  // Configuration du jeu
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let width, height;
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  resize();
  window.addEventListener('resize', resize);

  // Personnage : cœur
  class Heart {
    constructor() {
      this.x = width * 0.2;
      this.y = height / 2;
      this.radius = 20;
      this.velocity = 0;
      this.gravity = 0.6;
      this.lift = -10;
      this.maxVelocity = 12;
      this.animationTick = 0;
    }

    update() {
      this.velocity += this.gravity;
      if(this.velocity > this.maxVelocity) this.velocity = this.maxVelocity;
      this.y += this.velocity;

      // Anim cœur battant doucement (scale pulsé)
      this.animationTick += 0.1;
      this.scale = 1 + 0.05 * Math.sin(this.animationTick * 3);

      // Limites écran
      if(this.y + this.radius > height) {
        this.y = height - this.radius;
        this.velocity = 0;
      }
      if(this.y - this.radius < 0) {
        this.y = this.radius;
        this.velocity = 0;
      }
    }

    fly() {
      this.velocity = this.lift;
    }

    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(this.scale, this.scale);
      // Dessiner cœur simple cartoon stylisé
      ctx.fillStyle = '#e63946';
      ctx.strokeStyle = '#b22234';
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-15, -15, -15, 10, 0, 25);
      ctx.bezierCurveTo(15, 10, 15, -15, 0, 0);
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }
  }

  // Obstacles : troncs d'arbre
  class Trunk {
    constructor(x) {
      this.x = x;
      this.width = 50;
      this.gap = 140;
      this.topHeight = Math.floor(Math.random() * (height / 2)) + 50;
      this.speed = 3;
    }

    update() {
      this.x -= this.speed;
      if(this.x + this.width < 0) {
        this.x = width + 200;
        this.topHeight = Math.floor(Math.random() * (height / 2)) + 50;
      }
    }

    draw() {
      ctx.fillStyle = '#7b5e2e';
      ctx.strokeStyle = '#4b3b1b';
      ctx.lineWidth = 3;

      // Texture simple troncs avec lignes verticales
      // Tronc haut
      ctx.fillRect(this.x, 0, this.width, this.topHeight);
      for(let i=0; i<6; i++) {
        ctx.beginPath();
        let lineX = this.x + i * 8 + 5;
        ctx.moveTo(lineX, 0);
        ctx.lineTo(lineX, this.topHeight);
        ctx.stroke();
      }

      // Tronc bas
      let bottomY = this.topHeight + this.gap;
      let bottomHeight = height - bottomY;
      ctx.fillRect(this.x, bottomY, this.width, bottomHeight);
      for(let i=0; i<6; i++) {
        ctx.beginPath();
        let lineX = this.x + i * 8 + 5;
        ctx.moveTo(lineX, bottomY);
        ctx.lineTo(lineX, height);
        ctx.stroke();
      }
    }
  }

  // Nuages animés
  const cloudsContainer = document.getElementById('clouds');
  function createCloud(size, top, delay, duration, left) {
    const cloud = document.createElement('div');
    cloud.classList.add('cloud');
    cloud.style.width = size + 'px';
    cloud.style.height = (size * 0.6) + 'px';
    cloud.style.top = top + '%';
    cloud.style.left = left + 'px';
    cloud.style.animationDuration = duration + 's';
    cloud.style.animationDelay = delay + 's';
    cloudsContainer.appendChild(cloud);
  }
  // Création de quelques nuages
  createCloud(120, 15, 0, 60, -150);
  createCloud(80, 25, 10, 50, -100);
  createCloud(100, 10, 5, 70, -130);
  createCloud(90, 20, 7, 55, -140);

  // Construction ville simple dans background
  const bg = document.getElementById('background');
  function createBuilding(widthB, heightB, leftB) {
    const b = document.createElement('div');
    b.classList.add('building');
    b.style.width = widthB + 'px';
    b.style.height = heightB + 'px';
    b.style.left = leftB + 'px';
    bg.appendChild(b);
  }
  // Création bâtiments variés
  let totalWidth = 0;
  while(totalWidth < window.innerWidth + 200) {
    const wB = 40 + Math.random() * 40;
    const hB = 80 + Math.random() * 150;
    createBuilding(wB, hB, totalWidth);
    totalWidth += wB + 15;
  }

  // Gestion jeu
  let heart = new Heart();
  let trunks = [];
  const trunkCount = 3;
  const trunkSpacing = 300;

  for(let i=0; i<trunkCount; i++) {
    trunks.push(new Trunk(width + i * trunkSpacing));
  }

  let score = 0;
  let gameOver = false;

  // Affichage score
  function drawScore() {
    ctx.fillStyle = '#d6366e';
    ctx.font = 'bold 32px Comic Sans MS';
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 4;
    ctx.fillText(`Score : ${score}`, 20, 50);
  }

  // Collision simple
  function collision(h, t) {
    // Vérifier collision avec troncs
    let withinX = h.x + h.radius > t.x && h.x - h.radius < t.x + t.width;
    let withinYTop = h.y - h.radius < t.topHeight;
    let withinYBottom = h.y + h.radius > t.topHeight + t.gap;

    return withinX && (withinYTop || withinYBottom);
  }

  // Affichage message fin
  const messageBox = document.getElementById('messageBox');
  const restartBtn = document.getElementById('restartBtn');
  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  // Reset jeu
  function resetGame() {
    heart = new Heart();
    trunks = [];
    for(let i=0; i<trunkCount; i++) {
      trunks.push(new Trunk(width + i * trunkSpacing));
    }
    score = 0;
    gameOver = false;
    messageBox.style.display = 'none';
    animate();
  }

  // Main loop
  function animate() {
    if(gameOver) return;

    ctx.clearRect(0, 0, width, height);

    heart.update();
    heart.draw();

    trunks.forEach(t => {
      t.update();
      t.draw();

      if(collision(heart, t)) {
        gameOver = true;
        messageBox.style.display = 'block';
      }

      // Score update
      if(t.x + t.width < heart.x && !t.scored) {
        score++;
        t.scored = true;
      }
      if(t.x > heart.x) t.scored = false;
    });

    drawScore();

    if(!gameOver) requestAnimationFrame(animate);
  }

  // Événement tap/clic pour voler
  window.addEventListener('touchstart', e => {
    e.preventDefault();
    if(!gameOver) heart.fly();
  }, {passive: false});

  window.addEventListener('mousedown', e => {
    if(!gameOver) heart.fly();
  });

  // Démarrer
  animate();

</script>
</body>
</html>

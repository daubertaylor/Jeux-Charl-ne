<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>‚ù§Ô∏è Flappy Heart</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Baloo+2&display=swap');
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    height: 100%;
    overflow: hidden;
    background: linear-gradient(to top, #0b253d 0%, #4a86e8 70%, #a6c1f0 100%);
    font-family: 'Baloo 2', cursive;
    -webkit-tap-highlight-color: transparent;
  }
  canvas {
    display: block;
    background: transparent;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20,20,30,0.85);
    color: #fff;
    padding: 1.5em 2em;
    border-radius: 15px;
    text-align: center;
    font-size: 1.3rem;
    max-width: 90vw;
    display: none;
    user-select: none;
  }
  #message button {
    margin-top: 1em;
    background: #ff1e3c;
    border: none;
    border-radius: 8px;
    padding: 0.7em 1.5em;
    font-weight: bold;
    color: white;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #message button:hover {
    background: #e6002e;
  }
  /* Nuages */
  .cloud {
    position: absolute;
    background: #eef2f7;
    border-radius: 50%;
    opacity: 0.8;
    box-shadow:
      30px 20px 0 0 #eef2f7,
      60px 20px 0 0 #eef2f7,
      45px 10px 0 0 #eef2f7;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="message">
  <p>Ce n‚Äôest pas grave mon amour üíî<br>Tu as tout donn√©, je suis fier de toi.</p>
  <button id="restartBtn">Recommencer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W, H, scaleRatio;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * devicePixelRatio;
    canvas.height = H * devicePixelRatio;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
    scaleRatio = Math.min(W/375, H/667);
  }
  resize();
  window.addEventListener('resize', resize);

  // Variables jeu
  const gravity = 0.6;
  const jumpForce = -11;
  const obstacleWidth = 50;
  const obstacleGap = 160 * scaleRatio;
  const obstacleDist = 250 * scaleRatio;
  const scrollSpeed = 3 * scaleRatio;

  let heart = {
    x: W / 4,
    y: H / 2,
    vy: 0,
    size: 40 * scaleRatio,
    pulseTime: 0,
  };

  let obstacles = [];
  let frames = 0;
  let score = 0;
  let running = true;

  // Message & restart
  const messageDiv = document.getElementById('message');
  const restartBtn = document.getElementById('restartBtn');

  restartBtn.onclick = () => {
    score = 0;
    heart.y = H / 2;
    heart.vy = 0;
    obstacles = [];
    frames = 0;
    running = true;
    messageDiv.style.display = 'none';
    loop();
  };

  // Fonctions dessin

  // C≈ìur rouge stylis√© avec ombrage et l√©ger volume
  function drawHeart(x, y, size, pulseScale = 1, bounce = 0) {
    ctx.save();
    ctx.translate(x, y + bounce);
    ctx.scale(pulseScale, pulseScale);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    // path coeur
    const topCurveHeight = size * 0.3;
    ctx.moveTo(0, topCurveHeight);
    ctx.bezierCurveTo(0, 0, -size / 2, 0, -size / 2, topCurveHeight);
    ctx.bezierCurveTo(-size / 2, size / 2, 0, size * 0.75, 0, size);
    ctx.bezierCurveTo(0, size * 0.75, size / 2, size / 2, size / 2, topCurveHeight);
    ctx.bezierCurveTo(size / 2, 0, 0, 0, 0, topCurveHeight);
    ctx.closePath();

    // Ombre
    const grad = ctx.createRadialGradient(0, size/2, size*0.1, 0, size/2, size);
    grad.addColorStop(0, '#ff4b5c');
    grad.addColorStop(1, '#b0001a');

    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(255, 75, 92, 0.8)';
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.restore();
  }

  // Arbres stylis√©s (troncs et feuillages)
  function drawTree(x, y, height, sway=0) {
    // tronc
    ctx.save();
    ctx.translate(x + sway, y);
    ctx.fillStyle = '#5b3a1a';
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowBlur = 3;
    ctx.fillRect(-8 * scaleRatio, 0, 16 * scaleRatio, height);
    ctx.restore();

    // feuillage (3 boules)
    ctx.save();
    ctx.translate(x + sway, y);
    ctx.fillStyle = '#2a4d14';
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    const leafRadius = 20 * scaleRatio;
    ctx.beginPath();
    ctx.ellipse(0, -leafRadius * 0.5, leafRadius, leafRadius * 0.7, 0, 0, Math.PI*2);
    ctx.ellipse(-leafRadius, -leafRadius * 1.5, leafRadius, leafRadius, 0, 0, Math.PI*2);
    ctx.ellipse(leafRadius, -leafRadius * 1.5, leafRadius, leafRadius, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Lampadaire urbain stylis√©
  function drawLamp(x, y, sway=0) {
    ctx.save();
    ctx.translate(x + sway, y);
    // poteau
    ctx.fillStyle = '#444';
    ctx.fillRect(-3 * scaleRatio, 0, 6 * scaleRatio, 80 * scaleRatio);
    // lampe
    ctx.beginPath();
    ctx.arc(0, 0, 15 * scaleRatio, 0, Math.PI * 2);
    ctx.fillStyle = '#ffd';
    ctx.shadowColor = 'rgba(255,255,180,0.7)';
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.restore();
  }

  // Maisons stylis√©es en silhouette
  function drawHouse(x, y, scale=1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.fillStyle = '#776655';
    // mur
    ctx.fillRect(-20, 0, 40, 30);
    // toit
    ctx.beginPath();
    ctx.moveTo(-25, 0);
    ctx.lineTo(0, -25);
    ctx.lineTo(25, 0);
    ctx.closePath();
    ctx.fillStyle = '#4a3b2f';
    ctx.fill();
    // fen√™tre
    ctx.fillStyle = '#999966';
    ctx.fillRect(-10, 10, 10, 10);
    ctx.fillRect(5, 10, 10, 10);
    ctx.restore();
  }

  // Nuage simple avec contours nets
  function drawCloud(x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(240,240,245,0.85)';
    ctx.shadowColor = 'rgba(200,200,210,0.7)';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.6, size * 0.4, 0, 0, Math.PI * 2);
    ctx.ellipse(size * 0.5, -size * 0.1, size * 0.55, size * 0.45, 0, 0, Math.PI * 2);
    ctx.ellipse(size * 0.9, size * 0.1, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Oiseau minimaliste
  function drawBird(x, y, wingOpen) {
    ctx.save();
    ctx.translate(x, y);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    if(wingOpen){
      ctx.moveTo(-10, 0);
      ctx.lineTo(0, -7);
      ctx.lineTo(10, 0);
    } else {
      ctx.moveTo(-10, 0);
      ctx.lineTo(0, 7);
      ctx.lineTo(10, 0);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Effet √©tincelle rouge √† chaque passage d'obstacle
  class Sparkle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.life = 12;
      this.particles = [];
      for(let i=0; i<15; i++){
        this.particles.push({
          x: this.x,
          y: this.y,
          vx: (Math.random()-0.5)*3,
          vy: (Math.random()-0.5)*3,
          alpha: 1,
          size: 2 + Math.random()*2,
        });
      }
    }
    update() {
      this.life--;
      this.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.08;
        if(p.alpha<0) p.alpha=0;
      });
    }
    draw() {
      this.particles.forEach(p => {
        ctx.fillStyle = `rgba(255,50,50,${p.alpha.toFixed(2)})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      });
    }
    isDead() {
      return this.life <= 0;
    }
  }

  let sparkles = [];

  // G√©n√©ration obstacles
  function addObstacle() {
    const hTop = 80 + Math.random() * (H/2);
    const isTree = Math.random() < 0.7;
    obstacles.push({
      x: W + obstacleWidth,
      topHeight: hTop,
      bottomY: hTop + obstacleGap,
      isTree: isTree,
      sway: 0,
      swayDir: Math.random() < 0.5 ? 1 : -1,
      swaySpeed: 0.03 + Math.random()*0.02,
      lamp: !isTree && Math.random() < 0.6,
      lampOffset: 0
    });
  }

  // Reset et init obstacles
  addObstacle();

  // Gameplay loop
  function loop() {
    if(!running) return;
    frames++;
    ctx.clearRect(0, 0, W, H);

    // Background d√©grad√© ciel
    const skyGradient = ctx.createLinearGradient(0, 0, 0, H);
    skyGradient.addColorStop(0, '#0b253d');
    skyGradient.addColorStop(0.7, '#4a86e8');
    skyGradient.addColorStop(1, '#a6c1f0');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, W, H);

    // Nuages anim√©s
    const cloudCount = 5;
    for(let i=0; i<cloudCount; i++) {
      const x = (frames*0.2 + i*150) % (W + 200) - 100;
      const y = 80 + 40 * Math.sin((frames*0.01 + i)*2);
      drawCloud(x, y, 70);
    }

    // Montagnes/arri√®re-plan simple
    ctx.fillStyle = '#3e4a61';
    ctx.beginPath();
    ctx.moveTo(0, H);
    ctx.lineTo(80 * scaleRatio, H - 120 * scaleRatio);
    ctx.lineTo(150 * scaleRatio, H - 80 * scaleRatio);
    ctx.lineTo(230 * scaleRatio, H - 140 * scaleRatio);
    ctx.lineTo(320 * scaleRatio, H - 100 * scaleRatio);
    ctx.lineTo(W, H - 150 * scaleRatio);
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fill();

    // Maisons silhouettes
    for(let i=0; i<5; i++) {
      const x = (frames*1.5 + i*300) % (W + 300) - 150;
      const y = H - 80 * scaleRatio;
      drawHouse(x, y, 1 * scaleRatio);
    }

    // Oiseaux volants
    for(let i=0; i<3; i++) {
      const x = (frames*3 + i*250) % (W + 50) - 50;
      const y = 150 + 40 * Math.sin(frames*0.04 + i);
      drawBird(x, y, Math.floor(frames/10 + i) % 2 === 0);
    }

    // Obstacles - arbres et lampadaires
    for(let i=obstacles.length-1; i>=0; i--) {
      const o = obstacles[i];
      o.x -= scrollSpeed;
      o.sway += o.swayDir * o.swaySpeed;
      if(o.sway > 3) o.swayDir = -1;
      if(o.sway < -3) o.swayDir = 1;

      // Haut (obstacle)
      if(o.isTree){
        drawTree(o.x, 0, o.topHeight, o.sway);
      } else {
        // lampadaire en haut
        ctx.save();
        ctx.translate(o.x + o.sway, o.topHeight - 80 * scaleRatio);
        drawLamp(0, 0);
        ctx.restore();
        // mur pierre
        ctx.fillStyle = '#666';
        ctx.fillRect(o.x - obstacleWidth/2, 0, obstacleWidth, o.topHeight);
      }

      // Bas (obstacle)
      if(o.isTree){
        drawTree(o.x, o.bottomY, H - o.bottomY, o.sway);
      } else {
        ctx.save();
        ctx.translate(o.x + o.sway, o.bottomY);
        drawLamp(0, 0);
        ctx.restore();
        ctx.fillStyle = '#666';
        ctx.fillRect(o.x - obstacleWidth/2, o.bottomY, obstacleWidth, H - o.bottomY);
      }

      // Suppression quand hors √©cran
      if(o.x + obstacleWidth < 0) obstacles.splice(i,1);

      // Ajout obstacle si proche du bord
      if(obstacles.length < 4){
        const last = obstacles[obstacles.length-1];
        if(last && (W - last.x) > obstacleDist) addObstacle();
      }
    }

    // Physique c≈ìur
    heart.vy += gravity;
    heart.y += heart.vy;

    // Pulsation coeur
    heart.pulseTime += 0.1;
    const pulseScale = 1 + Math.sin(heart.pulseTime)*0.08;

    // Rebond petit quand tap
    let bounce = 0;
    if(tapRecently){
      bounce = Math.sin(tapTimer * 0.5) * 8 * scaleRatio;
      tapTimer++;
      if(tapTimer > 20) {
        tapRecently = false;
      }
    }

    drawHeart(heart.x, heart.y, heart.size, pulseScale, bounce);

    // Collision detection
    function collidesRectCircle(rx, ry, rw, rh, cx, cy, cr) {
      // trouver le point le plus proche dans le rectangle vers le cercle
      let testX = cx;
      let testY = cy;

      if(cx < rx) testX = rx;
      else if(cx > rx + rw) testX = rx + rw;
      if(cy < ry) testY = ry;
      else if(cy > ry + rh) testY = ry + rh;

      const distX = cx - testX;
      const distY = cy - testY;
      const distance = Math.sqrt(distX*distX + distY*distY);

      return distance <= cr;
    }

    // Check collision avec obstacles
    const radius = heart.size * 0.5;
    for(let o of obstacles){
      // Haut
      if(collidesRectCircle(o.x - obstacleWidth/2, 0, obstacleWidth, o.topHeight, heart.x, heart.y, radius))
